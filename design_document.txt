Design Document:

Table of Contents : Design Document
-System Overview
-Implementation Details
-Use Case Support in Design

List of Contributors:

The following team members contributed to the creation of this document:
-Utku Karatepe 
-Emirhan Gül 
-Taha Tavlan 

This document should detail the implementation approach and decision-making process. The
Design Document must be structured around 4 use cases. The following sections must be
included:

1. System Overview  
    ● Brief Project Description: Summarize the project and its goals in 1-2 paragraphs:
        Mobil tabanlı EduRank uygulaması sayesinde kullanıcılar test çözebilecek, çalışma 
        sonuçlarını, çalışma sürelerini karşılaştırabilecek. Ayrıca sadece çalışma süresini arkadaşlarıyla 
        karşılaştırmak isteyen bir kullanıcı, uygulama üzerinden test çözme zorunluluğu olmadan da sayaç 
        özelliğini kullanarak toplam çalışma süresine katkıda bulunabilecek. Kullanıcılar hesap 
        oluşturabilecek, testler çözebilecek, istatistiklerini analiz edebilecek ve başarı oranı veya çalışma 
        süresi istatistikleri sayesinde arkadaşlarıyla rekabet edebilecek. Bu proje, insanların çalışma 
        sürecini takip edebilmelerini sağlayarak ve çalışma alışkanlıkları hakkında analizler sunarak 
        verimliliği artırmayı, sorumluluk duygusunu geliştirmeyi ve öğrenme sürecinde insanları teşvik etmeyi 
        amaçlamaktadır.


    ● System Architecture: Provide an overview of the system architecture (e.g., layered,
    microservices):
        Uygulamamız, Layered Architecture ve Client-Server mimari modelini takip etmektedir. 
        Sistem üç ana bileşenden oluşmaktadır: Kullanıcı arayüzü (Flutter), backend API (Flask) 
        ve veritabanı (MySQL). Kullanıcı, Flutter uygulaması aracılığıyla işlemlerini gerçekleştirir.
        Flutter istemcisi, Flask backend API’sine HTTP istekleri göndererek veri alıp/gönderir. 
        Backend katmanı, bu istekleri işleyerek MySQL veritabanıyla iletişim kurar ve gerekli 
        işlemleri yürütür. Katmanlı mimari sayesinde, her bileşen birbirinden bağımsız olarak 
        geliştirilebilir ve ölçeklenebilir bir yapı sağlanır.

        +--------------------+
        |   Flutter (UI)     |  <----->  Kullanıcı ile etkileşim
        +--------------------+
                 |
                 v
        +--------------------+
        |  Flask (Backend)   |  <----->  İş mantığını yönetir
        +--------------------+
                 |
                 v
        +--------------------+
        |    MySQL (DB)      |  <----->  Verileri saklar ve yönetir
        +--------------------+


    ● Technology Stack: List the primary technologies used in the project (frontend, backend,
    databases, frameworks, etc.):
        frontend: Flutter-dart,
        backend: flask, MySQL, SQLite
        databases: MySQL, SQLite
        frameworks: Flutter.

2. Implementation Details
    ● Codebase Structure: Explain how the project is structured (folders, modules).
    ● Key Implementations:
        ○ Describe significant components or modules with explanations.
        ○ Explain core algorithms or business logic where applicable.

        Bileşenler ve Modüller:

        Kullanıcı Yönetimi: Kayıt, giriş, JWT ile kimlik doğrulama.
        Test Yönetimi: Test seçme, çözme, sorular arası geçiş, cevap değiştirme, sonuç kaydetme.
        Çalışma Süresi Takibi: Sayaç başlatma/durdurma, süreleri kaydetme, istatistik oluşturma.
        İstatistik & Veri Görselleştirme: Kullanıcı performans analizleri, grafik ve tablolar.
        Lider Tablosu: Çalışma süresi & test başarı oranına göre sıralama.

        Algoritmalar ve İş Mantığı:

        Kimlik Doğrulama: JWT token ile oturum yönetimi.
        Test Çözme: Sorular arası geçiş yapma, doğru cevap kontrolü ve başarı oranı hesaplama.
        Çalışma Süresi Takibi: Başlangıç-bitiş zaman damgalarıyla toplam süre kaydı.
        Lider Tablosu: Öncelik başarı oranı, eşitlikte çalışma süresine göre sıralama.
        Veri Görselleştirme: Çekilen istatistik verilerinin grafik ve tablolarla sunulması.

    ● Component Interfaces:
        ○ Define the interfaces of key components, including class/method signatures.
            Önemli ve temel metotların/bileşenlerin python taslak kodları:

            class User:
                def _init_(self, user_id: int, username: str, email: str, password_hash: str):
                    pass

                def register(self, username: str, email: str, password: str) -> bool:
                    """Kullanıcı kaydı oluşturur"""
                    pass

                def login(self, email: str, password: str) -> str:
                    """JWT Token döndürerek kullanıcı girişi yapar"""
                    pass

            class Test:
                def _init_(self, test_id: int, category: str, questions: list):
                    pass

                def start_test(self, user_id: int) -> dict:
                    """Kullanıcı için testi başlatır"""
                    pass

                def submit_answers(self, user_id: int, answers: dict) -> float:
                    """Test cevaplarını değerlendirir ve başarı oranı döndürür"""
                    pass

            class StudySession:
                def _init_(self, session_id: int, user_id: int, start_time: str, end_time: str):
                    pass

                def start_timer(self, user_id: int) -> bool:
                    """Çalışma süresi sayaç başlatır"""
                    pass

                def stop_timer(self, user_id: int) -> int:
                    """Sayaç durdurulur ve toplam çalışma süresi döndürülür"""
                    pass

            class Leaderboard:
                def _init_(self, user_id: int, study_time: int, test_score: float):
                    pass

                def get_ranking(self) -> list:
                    """Liderlik tablosunu sıralı olarak döndürür"""
                    pass


        ○ Provide API endpoint descriptions if applicable. 

        USER AUTHENTICATION:
         Method	Endpoint	Description	                                              Request Body
         POST	/register	Yeni kullanıcı kaydı oluşturur.	                              { "username": "string", "password": "string" }
         POST	/login	        Kullanıcı girişi yapar ve JWT döner.	                      { "username": "string", "password": "string" }
         GET	/profile	Kullanıcının profil bilgilerini döner (JWT gerekir).	      -
         POST	/refresh	Refresh token kullanarak yeni access token alır.	      -
         POST	/logout	        Kullanıcıyı çıkış yaptırır (Token blackliste alınır).         -

    ● Visual Interfaces:
        ○ Include wireframes or screenshots of user interfaces.

3. Use Case Support in Design
    ● Use Case Selection: Identify 4 important use cases from the Requirements
    Document:
        case 1: 
        1-Kullanıcılar hesap oluşturabilmeli
        2-Kullanıcılar şifreleriyle giriş yapabilmelidir
        3-Kullanıcılar hesaplarından çıkış yapabilmelidir

        case 2: 
        1-Kullanıcılar şifreleriyle giriş yapabilmelidir
        2-Kullanıcılar test kategorilerinden seçim yapabilmeli
        2-Kullanıcılar test çözebilmelidir
        3-Kullanıcılar test çözerken sorular arasında geçiş yapabilmeli
        4-Kullanıcılar test çözerken yanıtlarını değiştirebilmeli

        case 3: 
        1-Kullanıcılar şifreleriyle giriş yapabilmelidir
        2-Kullanıcılar çalışma sürelerini bir sayaç/kronometre yardımıyla kaydedebilmelidir
        3-Kullanıcılar birbirlerinin çalışma sürelerini görüntüleyebilmelidir

        case 4: 
        1-Kullanıcılar şifreleriyle giriş yapabilmelidir
        2-Kullanıcıların çalışma istatistikleri ve test sonuçları kaydedilmelidir/görüntülenebilmelidir
        3-Kullanıcılar birbirlerinin test başarı oranlarını görüntüleyebilmelidir(liderlik tablosu)

    ● Requirement Mapping: Clearly state which functional requirements correspond to each
    use case.
    ● Use Case Design:
        ○ Detail how the system architecture supports each use case.
        ○ Provide diagrams or explanations of data flow, state changes, and interactions.
    ● Demo Requirement:
        ○ These four use cases must be fully implemented and will be demonstrated
        during the final project presentation.

4. Design Decisions
    ● Technology Comparisons: Compare at least two alternative technologies used in the
    project.
 
    Veritabanı Teknolojileri – SQLite vs. PostgreSQL
          
    Özellik	        SQLite	                                                                               PostgreSQL
    Performans:	        Küçük ölçekli uygulamalar için hızlıdır	                                               Büyük ölçekli uygulamalarda daha verimlidir
    Eşzamanlılık:	Aynı anda tek bir yazma işlemi yapabilir (çok kullanıcılı sistemler için uygun değil)  Birden fazla kullanıcının aynı anda yazma işlemi yapmasına izin verir
    Depolama:	        Dosya tabanlıdır (.db dosyası yerelde saklanır)	                                       Sunucu tabanlıdır, yapılandırma gerektirir
    Kullanım Alanı:	Küçük projeler, test ortamları ve yerel geliştirme için uygundur	               Çok kullanıcılı sistemler ve yüksek veri işleyen uygulamalar için daha iyidir
    Veri Bütünlüğü:	Temel ACID (Atomicity, Consistency, Isolation, Durability) desteği sunar	       Tam ACID uyumluluğu sağlar, karmaşık işlemler için daha güvenlidir
  

    Kimlik Doğrulama Yöntemleri: JWT vs. Oturum Tabanlı Kimlik Doğrulama

    Özellik	        JWT (JSON Web Token)	                                                Oturum Tabanlı Kimlik Doğrulama
    Depolama:	        İstemci tarafında (localStorage, cookie) saklanır	                Sunucuda saklanır
    Güvenlik:	        HTTPS kullanıldığında güvenlidir, ancak token çalınma riski vardır	Sunucuda saklandığı için daha güvenlidir
    Ölçeklenebilirlik:	Sunucuda oturum saklamadığı için daha ölçeklenebilir	                Sunucunun oturumları takip etmesi gerekir, fazla bellek kullanır
    Performans:	        Token doğrulama ile hızlı çalışır	                                Sunucu tarafında ek işlem gerektiğinden biraz daha yavaş olabilir
    Kullanım Alanı:	API tabanlı sistemler ve mobil uygulamalar için idealdir	        Geleneksel web uygulamalarında daha uygundur


    ● Decision Justifications: Justify choices for databases, frameworks, and architecture.
    
    Flask: Flask, Python tabanlı hafif bir web framework'üdür. Basit ve esnek olması nedeniyle küçük ve orta ölçekli projeler için idealdir. Özellikle RESTful API geliştirme konusunda sıkça tercih edilir.

    Flask’in Avantajları:
    Hafif ve Minimal: Django gibi büyük framework'lere kıyasla, yalnızca ihtiyacınız olan modülleri ekleyerek çalışabilirsiniz.
    Kolay Öğrenilebilir: Python ile çalıştığı için basit bir sözdizimi vardır.
    Esneklik: İhtiyaca göre özelleştirilebilir.
    Geniş Eklenti Desteği: Authentication (kimlik doğrulama), veritabanı yönetimi gibi özellikler için eklentiler sunar. 

    Flask Kullanım Alanları:
    Küçük ve orta ölçekli web uygulamaları
    RESTful API geliştirme (sizin projeniz gibi)
    Mikroservis mimarisi
    Veri analiz ve görselleştirme uygulamaları

    
    SQLite: SQLite, hafif ve gömülü bir ilişkisel veritabanı yönetim sistemidir (RDBMS). Flask ile geliştirdiğiniz API'de verileri depolamak için kullanıyorsunuz.

    SQLite’in Avantajları:
    Sunucusuz: PostgreSQL veya MySQL gibi ayrı bir sunucu gerektirmez. Tüm veritabanı tek bir dosyada saklanır.
    Hafif ve Hızlı: Küçük ve orta ölçekli projeler için idealdir.
    Kolay Entegrasyon: Flask ile doğrudan entegre edilebilir.
    SQL Destekler: Standart SQL sorguları ile çalışır.

    SQLite’in Kullanım Alanları:
    Küçük ölçekli web ve mobil uygulamalar
    Test ortamlarında veritabanı olarak
    Cihaz içi veri depolama (örneğin, Android ve iOS uygulamalarında)


    RESTful API: RESTful API, web tabanlı uygulamalar için veri alışverişi yapmayı sağlayan bir API türüdür. REST (Representational State Transfer) prensiplerine dayanır ve HTTP protokolünü kullanır.
    
    RESTful API’nin Temel Özellikleri:
    İstemci-Sunucu Modeli: İstemci (frontend) ile sunucu (backend) birbirinden bağımsızdır.
    Stateless (Durumsuzluk): Her istek bağımsızdır, sunucu istemcinin önceki durumunu hatırlamaz.
    Kaynak Temelli: API, belirli kaynakları (users, quizzes, questions) URL'ler aracılığıyla yönetir.
    HTTP Metodlarını Kullanır:
    GET → Veri almak için
    POST → Yeni veri eklemek için
    PUT/PATCH → Veriyi güncellemek için
    DELETE → Veriyi silmek için

5. GitHub Commit Requirement
    ● Code Implementations & Interfaces & Technology Comparisons: Students must upload their implementations,
    component interfaces, and visual interface designs to GitHub. The code snippets used for comparison must also be
    committed to the repository.

        Kodlama süreci devam etmekte olup, proje süreci GitHub üzerinden yönetildiği için 
        Kod geliştirme süreci sürdükçe istenen tüm kod bileşenleri ve teknoloji 
        karşılaştırmalarına dair kod parçacıkları da düzenli olarak paylaşılacaktır.

Task Matrix :

System Overview               
Implementation Details      
Use Case Support in Design     Emirhan GÜl
Design Decisions               Utku Karatepe
GitHub Commit Requirement      Taha Tavlan
